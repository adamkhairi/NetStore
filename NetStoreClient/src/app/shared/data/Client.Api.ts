/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.13.2.0 (NJsonSchema v10.5.2.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import {catchError as _observableCatch, mergeMap as _observableMergeMap} from 'rxjs/operators';
import {Observable, of as _observableOf, throwError as _observableThrow} from 'rxjs';
import {Inject, Injectable, InjectionToken, Optional} from '@angular/core';
import {HttpClient, HttpHeaders, HttpResponse, HttpResponseBase} from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface IAuthClientApi {
    /**
     * Add New User and Return Token
     * @param body (optional)
     * @return Success
     */
    register(body?: RegisterModel | undefined): Observable<AuthModel>;

    /**
     * Return Login Token
     * @param body (optional)
     * @return Success
     */
    login(body?: TokenRequestModel | undefined): Observable<AuthModel>;
}

@Injectable({
    providedIn: 'root'
})
export class AuthClientApi implements IAuthClientApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Add New User and Return Token
     * @param body (optional)
     * @return Success
     */
    register(body?: RegisterModel | undefined): Observable<AuthModel> {
        let url_ = this.baseUrl + "/api/v1/Auth/Register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(<any>response_);
                } catch (e) {
                    return <Observable<AuthModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthModel>><any>_observableThrow(response_);
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<AuthModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AuthModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = AuthModel.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthModel>(<any>null);
    }

    /**
     * Return Login Token
     * @param body (optional)
     * @return Success
     */
    login(body?: TokenRequestModel | undefined): Observable<AuthModel> {
        let url_ = this.baseUrl + "/api/v1/Auth/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<AuthModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthModel>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<AuthModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AuthModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = AuthModel.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthModel>(<any>null);
    }
}

export interface ICartItemsClientApi {
    /**
     * Return List of ResponceCartItem
     * @return Success
     */
    getCartItem(userId: string): Observable<ResponceCartItem[]>;

    /**
     * Delete All CartItems By User
     * @return Success
     */
    deleteCartItem(userId: string): Observable<boolean>;

    /**
     * Post new CartItem
     * @param body (optional)
     * @return Success
     */
    postCartItem(body?: CartItemRequest | undefined): Observable<boolean>;

    /**
     * Count CartItems by User
     * @return Success
     */
    countCartItems(userId: string): Observable<CountResponce>;

    /**
     * Count SubTotal of the CartItems By User
     * @return Success
     */
    subTotalCartItem(userId: string): Observable<SubTotalAmountResponce>;

    /**
     * Count Total of the CartItems By User
     * @return Success
     */
    totalItems(userId: string): Observable<TotalItemsQtyResponce>;
}

@Injectable({
    providedIn: 'root'
})
export class CartItemsClientApi implements ICartItemsClientApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Return List of ResponceCartItem
     * @return Success
     */
    getCartItem(userId: string): Observable<ResponceCartItem[]> {
        let url_ = this.baseUrl + "/api/v1/CartItems/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCartItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCartItem(<any>response_);
                } catch (e) {
                    return <Observable<ResponceCartItem[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponceCartItem[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCartItem(response: HttpResponseBase): Observable<ResponceCartItem[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ResponceCartItem.fromJS(item));
                } else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result204: any = null;
                let resultData204 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData204)) {
                    result204 = [] as any;
                    for (let item of resultData204)
                        result204!.push(ResponceCartItem.fromJS(item));
                } else {
                    result204 = <any>null;
                }
                return _observableOf(result204);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponceCartItem[]>(<any>null);
    }

    /**
     * Delete All CartItems By User
     * @return Success
     */
    deleteCartItem(userId: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/CartItems/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteCartItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCartItem(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCartItem(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Post new CartItem
     * @param body (optional)
     * @return Success
     */
    postCartItem(body?: CartItemRequest | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/CartItems";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPostCartItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostCartItem(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostCartItem(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Count CartItems by User
     * @return Success
     */
    countCartItems(userId: string): Observable<CountResponce> {
        let url_ = this.baseUrl + "/api/v1/CartItems/CountCartItems/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCountCartItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountCartItems(<any>response_);
                } catch (e) {
                    return <Observable<CountResponce>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountResponce>><any>_observableThrow(response_);
        }));
    }

    protected processCountCartItems(response: HttpResponseBase): Observable<CountResponce> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = CountResponce.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Success", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountResponce>(<any>null);
    }

    /**
     * Count SubTotal of the CartItems By User
     * @return Success
     */
    subTotalCartItem(userId: string): Observable<SubTotalAmountResponce> {
        let url_ = this.baseUrl + "/api/v1/CartItems/SubTotalCartItem/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processSubTotalCartItem(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubTotalCartItem(<any>response_);
                } catch (e) {
                    return <Observable<SubTotalAmountResponce>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubTotalAmountResponce>><any>_observableThrow(response_);
        }));
    }

    protected processSubTotalCartItem(response: HttpResponseBase): Observable<SubTotalAmountResponce> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = SubTotalAmountResponce.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Success", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubTotalAmountResponce>(<any>null);
    }

    /**
     * Count Total of the CartItems By User
     * @return Success
     */
    totalItems(userId: string): Observable<TotalItemsQtyResponce> {
        let url_ = this.baseUrl + "/api/v1/CartItems/TotalItems/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processTotalItems(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTotalItems(<any>response_);
                } catch (e) {
                    return <Observable<TotalItemsQtyResponce>><any>_observableThrow(e);
                }
            } else
                return <Observable<TotalItemsQtyResponce>><any>_observableThrow(response_);
        }));
    }

    protected processTotalItems(response: HttpResponseBase): Observable<TotalItemsQtyResponce> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = TotalItemsQtyResponce.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Success", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<TotalItemsQtyResponce>(<any>null);
    }
}

export interface ICategoriesClientApi {
    /**
     * Get All Categories
     * @return Success
     */
    getCategoryAll(): Observable<Category[]>;

    /**
     * Count SubTotal of the CartItems By User
     * @param body (optional)
     * @return Success
     */
    postCategory(body?: Category | undefined): Observable<Category>;

    /**
     * Get Category By Id
     * @return Success
     */
    getCategory(id: string): Observable<Category>;

    /**
     * Delete Category
     * @return Success
     */
    deleteCategory(id: string): Observable<void>;

    /**
     * Update Category
     * @param body (optional)
     * @return Success
     */
    putCategory(id: string, body?: Category | undefined): Observable<Category>;
}

@Injectable({
    providedIn: 'root'
})
export class CategoriesClientApi implements ICategoriesClientApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get All Categories
     * @return Success
     */
    getCategoryAll(): Observable<Category[]> {
        let url_ = this.baseUrl + "/api/v1/Categories";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCategoryAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategoryAll(<any>response_);
                } catch (e) {
                    return <Observable<Category[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Category[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategoryAll(response: HttpResponseBase): Observable<Category[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(Category.fromJS(item));
                } else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Success", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category[]>(<any>null);
    }

    /**
     * Count SubTotal of the CartItems By User
     * @param body (optional)
     * @return Success
     */
    postCategory(body?: Category | undefined): Observable<Category> {
        let url_ = this.baseUrl + "/api/v1/Categories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPostCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostCategory(<any>response_);
                } catch (e) {
                    return <Observable<Category>><any>_observableThrow(e);
                }
            } else
                return <Observable<Category>><any>_observableThrow(response_);
        }));
    }

    protected processPostCategory(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Category.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = ProblemDetails.fromJS(resultData401);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category>(<any>null);
    }

    /**
     * Get Category By Id
     * @return Success
     */
    getCategory(id: string): Observable<Category> {
        let url_ = this.baseUrl + "/api/v1/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetCategory(<any>response_);
                } catch (e) {
                    return <Observable<Category>><any>_observableThrow(e);
                }
            } else
                return <Observable<Category>><any>_observableThrow(response_);
        }));
    }

    protected processGetCategory(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Category.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category>(<any>null);
    }

    /**
     * Delete Category
     * @return Success
     */
    deleteCategory(id: string): Observable<void> {
        let url_ = this.baseUrl + "/api/v1/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({})
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return _observableOf<void>(<any>null);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = ProblemDetails.fromJS(resultData401);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Update Category
     * @param body (optional)
     * @return Success
     */
    putCategory(id: string, body?: Category | undefined): Observable<Category> {
        let url_ = this.baseUrl + "/api/v1/Categories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPutCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutCategory(<any>response_);
                } catch (e) {
                    return <Observable<Category>><any>_observableThrow(e);
                }
            } else
                return <Observable<Category>><any>_observableThrow(response_);
        }));
    }

    protected processPutCategory(response: HttpResponseBase): Observable<Category> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Category.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result404: any = null;
                let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result404 = ProblemDetails.fromJS(resultData404);
                return throwException("Not Found", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = ProblemDetails.fromJS(resultData401);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Category>(<any>null);
    }
}

export interface IOrdersClientApi {
    /**
     * Get Order By Id returns List ResponceOrderDetailDto
     * @return Success
     */
    getOrder(id: string): Observable<ResponceOrderDetailDto[]>;

    /**
     * Post Order (Request Order)
     * @param body (optional)
     * @return Success
     */
    postOrder(body?: RequestOrder | undefined): Observable<boolean>;

    /**
     * Get All Completed Orders
     * @return Success
     */
    completedOrders(): Observable<ResponceOrderDto[]>;

    /**
     * Get All Pending Orders
     * @return Success
     */
    pendingOrders(): Observable<ResponceOrderDto[]>;

    /**
     * Count All Orders
     * @return Success
     */
    countOrders(): Observable<CountResponce>;

    /**
     * Get Orders By User
     * @return Success
     */
    orderByUser(id: string): Observable<ResponceOrderDto[]>;

    /**
     * Mark Orders as Completed
     * @return Success
     */
    markOrderCompleted(id: string): Observable<boolean>;
}

@Injectable({
    providedIn: 'root'
})
export class OrdersClientApi implements IOrdersClientApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get Order By Id returns List ResponceOrderDetailDto
     * @return Success
     */
    getOrder(id: string): Observable<ResponceOrderDetailDto[]> {
        let url_ = this.baseUrl + "/api/v1/Orders/GetOrder/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOrder(<any>response_);
                } catch (e) {
                    return <Observable<ResponceOrderDetailDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponceOrderDetailDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetOrder(response: HttpResponseBase): Observable<ResponceOrderDetailDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ResponceOrderDetailDto.fromJS(item));
                } else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Success", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponceOrderDetailDto[]>(<any>null);
    }

    /**
     * Post Order (Request Order)
     * @param body (optional)
     * @return Success
     */
    postOrder(body?: RequestOrder | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/Orders";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPostOrder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostOrder(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostOrder(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Success", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Get All Completed Orders
     * @return Success
     */
    completedOrders(): Observable<ResponceOrderDto[]> {
        let url_ = this.baseUrl + "/api/v1/Orders/CompletedOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCompletedOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCompletedOrders(<any>response_);
                } catch (e) {
                    return <Observable<ResponceOrderDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponceOrderDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processCompletedOrders(response: HttpResponseBase): Observable<ResponceOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ResponceOrderDto.fromJS(item));
                } else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Success", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponceOrderDto[]>(<any>null);
    }

    /**
     * Get All Pending Orders
     * @return Success
     */
    pendingOrders(): Observable<ResponceOrderDto[]> {
        let url_ = this.baseUrl + "/api/v1/Orders/PendingOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPendingOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPendingOrders(<any>response_);
                } catch (e) {
                    return <Observable<ResponceOrderDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponceOrderDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processPendingOrders(response: HttpResponseBase): Observable<ResponceOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ResponceOrderDto.fromJS(item));
                } else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Success", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponceOrderDto[]>(<any>null);
    }

    /**
     * Count All Orders
     * @return Success
     */
    countOrders(): Observable<CountResponce> {
        let url_ = this.baseUrl + "/api/v1/Orders/CountOrders";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCountOrders(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountOrders(<any>response_);
                } catch (e) {
                    return <Observable<CountResponce>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountResponce>><any>_observableThrow(response_);
        }));
    }

    protected processCountOrders(response: HttpResponseBase): Observable<CountResponce> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = CountResponce.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Success", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountResponce>(<any>null);
    }

    /**
     * Get Orders By User
     * @return Success
     */
    orderByUser(id: string): Observable<ResponceOrderDto[]> {
        let url_ = this.baseUrl + "/api/v1/Orders/OrderByUser/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processOrderByUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOrderByUser(<any>response_);
                } catch (e) {
                    return <Observable<ResponceOrderDto[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponceOrderDto[]>><any>_observableThrow(response_);
        }));
    }

    protected processOrderByUser(response: HttpResponseBase): Observable<ResponceOrderDto[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(ResponceOrderDto.fromJS(item));
                } else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Success", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponceOrderDto[]>(<any>null);
    }

    /**
     * Mark Orders as Completed
     * @return Success
     */
    markOrderCompleted(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/Orders/MarkOrderCompleted/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processMarkOrderCompleted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMarkOrderCompleted(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processMarkOrderCompleted(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Success", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

export interface IStoreClientApi {
    /**
     * Count Products
     * @return Success
     */
    countProducts(): Observable<CountResponce>;

    /**
     * Get All Product Apply Pagination and Search
     * @param pageNumber (optional)
     * @param pageSize (optional)
     * @param title (optional)
     * @return Success
     */
    getProducts(pageNumber?: number | undefined, pageSize?: number | undefined, title?: string | undefined): Observable<ProductPagedResponce>;

    /**
     * Post New Product
     * @param body (optional)
     * @return Success
     */
    postProduct(body?: AddProductDTO | undefined): Observable<boolean>;

    /**
     * Get Product By Id
     * @return Success
     */
    getProduct(id: string): Observable<ResponceProductDTO>;

    /**
     * Update Product
     * @param body (optional)
     * @return Success
     */
    putProduct(id: string, body?: Product | undefined): Observable<Product>;

    /**
     * Delete Product
     * @return Success
     */
    deleteProduct(id: string): Observable<boolean>;

    /**
     * Get Products by Category Id
     * @return Success
     */
    getProductsByCategory(id: string): Observable<ProductListResponce>;

    /**
     * Get Top Products
     * @return Success
     */
    getTopProducts(): Observable<ProductListResponce>;
}

@Injectable({
    providedIn: 'root'
})
export class StoreClientApi implements IStoreClientApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Count Products
     * @return Success
     */
    countProducts(): Observable<CountResponce> {
        let url_ = this.baseUrl + "/api/v1/Store/CountProducts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processCountProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCountProducts(<any>response_);
                } catch (e) {
                    return <Observable<CountResponce>><any>_observableThrow(e);
                }
            } else
                return <Observable<CountResponce>><any>_observableThrow(response_);
        }));
    }

    protected processCountProducts(response: HttpResponseBase): Observable<CountResponce> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = CountResponce.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CountResponce>(<any>null);
    }

    /**
     * Get All Product Apply Pagination and Search
     * @param pageNumber (optional)
     * @param pageSize (optional)
     * @param title (optional)
     * @return Success
     */
    getProducts(pageNumber?: number | undefined, pageSize?: number | undefined, title?: string | undefined): Observable<ProductPagedResponce> {
        let url_ = this.baseUrl + "/api/v1/Store?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductPagedResponce>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductPagedResponce>><any>_observableThrow(response_);
        }));
    }

    protected processGetProducts(response: HttpResponseBase): Observable<ProductPagedResponce> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ProductPagedResponce.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Success", status, _responseText, _headers);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductPagedResponce>(<any>null);
    }

    /**
     * Post New Product
     * @param body (optional)
     * @return Success
     */
    postProduct(body?: AddProductDTO | undefined): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/Store";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPostProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostProduct(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processPostProduct(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = ProblemDetails.fromJS(resultData401);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Get Product By Id
     * @return Success
     */
    getProduct(id: string): Observable<ResponceProductDTO> {
        let url_ = this.baseUrl + "/api/v1/Store/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProduct(<any>response_);
                } catch (e) {
                    return <Observable<ResponceProductDTO>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponceProductDTO>><any>_observableThrow(response_);
        }));
    }

    protected processGetProduct(response: HttpResponseBase): Observable<ResponceProductDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ResponceProductDTO.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponceProductDTO>(<any>null);
    }

    /**
     * Update Product
     * @param body (optional)
     * @return Success
     */
    putProduct(id: string, body?: Product | undefined): Observable<Product> {
        let url_ = this.baseUrl + "/api/v1/Store/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processPutProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPutProduct(<any>response_);
                } catch (e) {
                    return <Observable<Product>><any>_observableThrow(e);
                }
            } else
                return <Observable<Product>><any>_observableThrow(response_);
        }));
    }

    protected processPutProduct(response: HttpResponseBase): Observable<Product> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = Product.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = ProblemDetails.fromJS(resultData401);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Product>(<any>null);
    }

    /**
     * Delete Product
     * @return Success
     */
    deleteProduct(id: string): Observable<boolean> {
        let url_ = this.baseUrl + "/api/v1/Store/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteProduct(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProduct(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteProduct(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = ProblemDetails.fromJS(resultData401);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    /**
     * Get Products by Category Id
     * @return Success
     */
    getProductsByCategory(id: string): Observable<ProductListResponce> {
        let url_ = this.baseUrl + "/api/v1/Store/GetProductsByCategory/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetProductsByCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProductsByCategory(<any>response_);
                } catch (e) {
                    return <Observable<ProductListResponce>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductListResponce>><any>_observableThrow(response_);
        }));
    }

    protected processGetProductsByCategory(response: HttpResponseBase): Observable<ProductListResponce> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ProductListResponce.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductListResponce>(<any>null);
    }

    /**
     * Get Top Products
     * @return Success
     */
    getTopProducts(): Observable<ProductListResponce> {
        let url_ = this.baseUrl + "/api/v1/Store/GetTopProducts";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetTopProducts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTopProducts(<any>response_);
                } catch (e) {
                    return <Observable<ProductListResponce>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProductListResponce>><any>_observableThrow(response_);
        }));
    }

    protected processGetTopProducts(response: HttpResponseBase): Observable<ProductListResponce> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = ProductListResponce.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("Success", status, _responseText, _headers);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProductListResponce>(<any>null);
    }
}

export interface IUsersClientApi {
    /**
     * Get All Users
     * @return Success
     */
    getUsers(): Observable<UserModel[]>;

    /**
     * Get User By Id
     * @param id (optional)
     * @return Success
     */
    getUser(id?: string | undefined): Observable<UserModel>;

    /**
     * Add New User
     * @param body (optional)
     * @return Success
     */
    addUser(body?: RegisterModel | undefined): Observable<AuthModel>;

    /**
     * Edit User
     * @param id (optional)
     * @param body (optional)
     * @return Success
     */
    editUser(id?: string | undefined, body?: EditUserModel | undefined): Observable<UserModel>;

    /**
     * Delete User
     * @param id (optional)
     * @return Success
     */
    deleteUser(id?: string | undefined): Observable<any>;

    /**
     * Return List of Users and Roles
     * @return Success
     */
    usersAndRoles(): Observable<any>;

    /**
     * Add User To Role (User Id, Role Name)
     * @param body (optional)
     * @return Success
     */
    addToRole(body?: AddRoleModel | undefined): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class UsersClientApi implements IUsersClientApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * Get All Users
     * @return Success
     */
    getUsers(): Observable<UserModel[]> {
        let url_ = this.baseUrl + "/api/v1/Users";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetUsers(response: HttpResponseBase): Observable<UserModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(UserModel.fromJS(item));
                } else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = ProblemDetails.fromJS(resultData401);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserModel[]>(<any>null);
    }

    /**
     * Get User By Id
     * @param id (optional)
     * @return Success
     */
    getUser(id?: string | undefined): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/v1/Users/GetUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(<any>response_);
                } catch (e) {
                    return <Observable<UserModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = UserModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = ProblemDetails.fromJS(resultData401);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserModel>(<any>null);
    }

    /**
     * Add New User
     * @param body (optional)
     * @return Success
     */
    addUser(body?: RegisterModel | undefined): Observable<AuthModel> {
        let url_ = this.baseUrl + "/api/v1/Users/AddUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processAddUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUser(<any>response_);
                } catch (e) {
                    return <Observable<AuthModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<AuthModel>><any>_observableThrow(response_);
        }));
    }

    protected processAddUser(response: HttpResponseBase): Observable<AuthModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = AuthModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = ProblemDetails.fromJS(resultData401);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AuthModel>(<any>null);
    }

    /**
     * Edit User
     * @param id (optional)
     * @param body (optional)
     * @return Success
     */
    editUser(id?: string | undefined, body?: EditUserModel | undefined): Observable<UserModel> {
        let url_ = this.baseUrl + "/api/v1/Users/EditUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processEditUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditUser(<any>response_);
                } catch (e) {
                    return <Observable<UserModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserModel>><any>_observableThrow(response_);
        }));
    }

    protected processEditUser(response: HttpResponseBase): Observable<UserModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = UserModel.fromJS(resultData200);
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = ProblemDetails.fromJS(resultData401);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserModel>(<any>null);
    }

    /**
     * Delete User
     * @param id (optional)
     * @return Success
     */
    deleteUser(id?: string | undefined): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Users/DeleteUser?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = ProblemDetails.fromJS(resultData401);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Return List of Users and Roles
     * @return Success
     */
    usersAndRoles(): Observable<any> {
        let url_ = this.baseUrl + "/api/v1/Users/UsersAndRoles";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processUsersAndRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUsersAndRoles(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processUsersAndRoles(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = ProblemDetails.fromJS(resultData401);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Add User To Role (User Id, Role Name)
     * @param body (optional)
     * @return Success
     */
    addToRole(body?: AddRoleModel | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/v1/Users/AddToRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_: any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processAddToRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddToRole(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processAddToRole(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result200 = resultData200 !== undefined ? resultData200 : <any>null;
                return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result400: any = null;
                let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result400 = ProblemDetails.fromJS(resultData400);
                return throwException("Bad Request", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result401: any = null;
                let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                result401 = ProblemDetails.fromJS(resultData401);
                return throwException("Unauthorized", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }
}

export interface IWeatherForecastClientApi {
    /**
     * @return Success
     */
    get(): Observable<WeatherForecast[]>;
}

@Injectable({
    providedIn: 'root'
})
export class WeatherForecastClientApi implements IWeatherForecastClientApi {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    /**
     * @return Success
     */
    get(): Observable<WeatherForecast[]> {
        let url_ = this.baseUrl + "/api/v1/WeatherForecast";
        url_ = url_.replace(/[?&]$/, "");

        let options_: any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_: any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<WeatherForecast[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<WeatherForecast[]>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<WeatherForecast[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
                (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {};
        if (response.headers) {
            for (let key of response.headers.keys()) {
                _headers[key] = response.headers.get(key);
            }
        }
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                let result200: any = null;
                let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
                if (Array.isArray(resultData200)) {
                    result200 = [] as any;
                    for (let item of resultData200)
                        result200!.push(WeatherForecast.fromJS(item));
                } else {
                    result200 = <any>null;
                }
                return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
                return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<WeatherForecast[]>(<any>null);
    }
}

export class AddProductDTO implements IAddProductDTO {
    id?: string | undefined;
    name?: string | undefined;
    shortDescription?: string | undefined;
    longDescription?: string | undefined;
    price?: number;
    stock?: number;
    color?: string | undefined;
    isTopProduct?: boolean;
    categoryId?: string | undefined;
    ref?: string | undefined;
    imgsByte?: string[] | undefined;
    imgsUrl?: string[] | undefined;

    constructor(data?: IAddProductDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.shortDescription = _data["shortDescription"];
            this.longDescription = _data["longDescription"];
            this.price = _data["price"];
            this.stock = _data["stock"];
            this.color = _data["color"];
            this.isTopProduct = _data["isTopProduct"];
            this.categoryId = _data["categoryId"];
            this.ref = _data["ref"];
            if (Array.isArray(_data["imgsByte"])) {
                this.imgsByte = [] as any;
                for (let item of _data["imgsByte"])
                    this.imgsByte!.push(item);
            }
            if (Array.isArray(_data["imgsUrl"])) {
                this.imgsUrl = [] as any;
                for (let item of _data["imgsUrl"])
                    this.imgsUrl!.push(item);
            }
        }
    }

    static fromJS(data: any): AddProductDTO {
        data = typeof data === 'object' ? data : {};
        let result = new AddProductDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["shortDescription"] = this.shortDescription;
        data["longDescription"] = this.longDescription;
        data["price"] = this.price;
        data["stock"] = this.stock;
        data["color"] = this.color;
        data["isTopProduct"] = this.isTopProduct;
        data["categoryId"] = this.categoryId;
        data["ref"] = this.ref;
        if (Array.isArray(this.imgsByte)) {
            data["imgsByte"] = [];
            for (let item of this.imgsByte)
                data["imgsByte"].push(item);
        }
        if (Array.isArray(this.imgsUrl)) {
            data["imgsUrl"] = [];
            for (let item of this.imgsUrl)
                data["imgsUrl"].push(item);
        }
        return data;
    }
}

export interface IAddProductDTO {
    id?: string | undefined;
    name?: string | undefined;
    shortDescription?: string | undefined;
    longDescription?: string | undefined;
    price?: number;
    stock?: number;
    color?: string | undefined;
    isTopProduct?: boolean;
    categoryId?: string | undefined;
    ref?: string | undefined;
    imgsByte?: string[] | undefined;
    imgsUrl?: string[] | undefined;
}

export class AddRoleModel implements IAddRoleModel {
    userId!: string;
    role!: string;

    constructor(data?: IAddRoleModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.role = _data["role"];
        }
    }

    static fromJS(data: any): AddRoleModel {
        data = typeof data === 'object' ? data : {};
        let result = new AddRoleModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["role"] = this.role;
        return data;
    }
}

export interface IAddRoleModel {
    userId: string;
    role: string;
}

export class ApplicationUser implements IApplicationUser {
    firstName!: string;
    lastName!: string;
    birthDate?: Date;
    gender?: string | undefined;
    address?: string | undefined;
    country?: string | undefined;
    state?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;

    constructor(data?: IApplicationUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.address = _data["address"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.zipCode = _data["zipCode"];
            this.id = _data["id"];
            this.userName = _data["userName"];
            this.normalizedUserName = _data["normalizedUserName"];
            this.email = _data["email"];
            this.normalizedEmail = _data["normalizedEmail"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.passwordHash = _data["passwordHash"];
            this.securityStamp = _data["securityStamp"];
            this.concurrencyStamp = _data["concurrencyStamp"];
            this.phoneNumber = _data["phoneNumber"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.twoFactorEnabled = _data["twoFactorEnabled"];
            this.lockoutEnd = _data["lockoutEnd"] ? new Date(_data["lockoutEnd"].toString()) : <any>undefined;
            this.lockoutEnabled = _data["lockoutEnabled"];
            this.accessFailedCount = _data["accessFailedCount"];
        }
    }

    static fromJS(data: any): ApplicationUser {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["address"] = this.address;
        data["country"] = this.country;
        data["state"] = this.state;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        data["id"] = this.id;
        data["userName"] = this.userName;
        data["normalizedUserName"] = this.normalizedUserName;
        data["email"] = this.email;
        data["normalizedEmail"] = this.normalizedEmail;
        data["emailConfirmed"] = this.emailConfirmed;
        data["passwordHash"] = this.passwordHash;
        data["securityStamp"] = this.securityStamp;
        data["concurrencyStamp"] = this.concurrencyStamp;
        data["phoneNumber"] = this.phoneNumber;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["twoFactorEnabled"] = this.twoFactorEnabled;
        data["lockoutEnd"] = this.lockoutEnd ? this.lockoutEnd.toISOString() : <any>undefined;
        data["lockoutEnabled"] = this.lockoutEnabled;
        data["accessFailedCount"] = this.accessFailedCount;
        return data;
    }
}

export interface IApplicationUser {
    firstName: string;
    lastName: string;
    birthDate?: Date;
    gender?: string | undefined;
    address?: string | undefined;
    country?: string | undefined;
    state?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
    id?: string | undefined;
    userName?: string | undefined;
    normalizedUserName?: string | undefined;
    email?: string | undefined;
    normalizedEmail?: string | undefined;
    emailConfirmed?: boolean;
    passwordHash?: string | undefined;
    securityStamp?: string | undefined;
    concurrencyStamp?: string | undefined;
    phoneNumber?: string | undefined;
    phoneNumberConfirmed?: boolean;
    twoFactorEnabled?: boolean;
    lockoutEnd?: Date | undefined;
    lockoutEnabled?: boolean;
    accessFailedCount?: number;
}

export class AuthModel implements IAuthModel {
    message?: string | undefined;
    isAuthenticated?: boolean;
    username?: string | undefined;
    userId?: string | undefined;
    email?: string | undefined;
    roles?: string[] | undefined;
    token?: string | undefined;
    expiresOn?: Date;

    constructor(data?: IAuthModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.message = _data["message"];
            this.isAuthenticated = _data["isAuthenticated"];
            this.username = _data["username"];
            this.userId = _data["userId"];
            this.email = _data["email"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.token = _data["token"];
            this.expiresOn = _data["expiresOn"] ? new Date(_data["expiresOn"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): AuthModel {
        data = typeof data === 'object' ? data : {};
        let result = new AuthModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["message"] = this.message;
        data["isAuthenticated"] = this.isAuthenticated;
        data["username"] = this.username;
        data["userId"] = this.userId;
        data["email"] = this.email;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["token"] = this.token;
        data["expiresOn"] = this.expiresOn ? this.expiresOn.toISOString() : <any>undefined;
        return data;
    }
}

export interface IAuthModel {
    message?: string | undefined;
    isAuthenticated?: boolean;
    username?: string | undefined;
    userId?: string | undefined;
    email?: string | undefined;
    roles?: string[] | undefined;
    token?: string | undefined;
    expiresOn?: Date;
}

export class CartItem implements ICartItem {
    id?: string | undefined;
    price?: number;
    qty?: number;
    isChecked?: boolean;
    totalAmount?: number;
    productId?: string | undefined;
    product?: Product;
    userId?: string | undefined;
    user?: ApplicationUser;

    constructor(data?: ICartItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.qty = _data["qty"];
            this.isChecked = _data["isChecked"];
            this.totalAmount = _data["totalAmount"];
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CartItem {
        data = typeof data === 'object' ? data : {};
        let result = new CartItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["qty"] = this.qty;
        data["isChecked"] = this.isChecked;
        data["totalAmount"] = this.totalAmount;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICartItem {
    id?: string | undefined;
    price?: number;
    qty?: number;
    isChecked?: boolean;
    totalAmount?: number;
    productId?: string | undefined;
    product?: Product;
    userId?: string | undefined;
    user?: ApplicationUser;
}

export class CartItemRequest implements ICartItemRequest {
    qty?: number;
    productId?: string | undefined;
    userId?: string | undefined;

    constructor(data?: ICartItemRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.qty = _data["qty"];
            this.productId = _data["productId"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): CartItemRequest {
        data = typeof data === 'object' ? data : {};
        let result = new CartItemRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["qty"] = this.qty;
        data["productId"] = this.productId;
        data["userId"] = this.userId;
        return data;
    }
}

export interface ICartItemRequest {
    qty?: number;
    productId?: string | undefined;
    userId?: string | undefined;
}

export class Category implements ICategory {
    id?: string | undefined;
    name!: string;
    description!: string;
    img?: string | undefined;
    imgUrl?: string | undefined;
    products?: Product[] | undefined;

    constructor(data?: ICategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.img = _data["img"];
            this.imgUrl = _data["imgUrl"];
            if (Array.isArray(_data["products"])) {
                this.products = [] as any;
                for (let item of _data["products"])
                    this.products!.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Category {
        data = typeof data === 'object' ? data : {};
        let result = new Category();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["img"] = this.img;
        data["imgUrl"] = this.imgUrl;
        if (Array.isArray(this.products)) {
            data["products"] = [];
            for (let item of this.products)
                data["products"].push(item.toJSON());
        }
        return data;
    }
}

export interface ICategory {
    id?: string | undefined;
    name: string;
    description: string;
    img?: string | undefined;
    imgUrl?: string | undefined;
    products?: Product[] | undefined;
}

export class CountResponce implements ICountResponce {
    counter?: number;

    constructor(data?: ICountResponce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.counter = _data["counter"];
        }
    }

    static fromJS(data: any): CountResponce {
        data = typeof data === 'object' ? data : {};
        let result = new CountResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["counter"] = this.counter;
        return data;
    }
}

export interface ICountResponce {
    counter?: number;
}

export class EditUserModel implements IEditUserModel {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    birthDate?: Date;
    gender!: string;
    address!: string;
    country!: string;
    state!: string;
    city!: string;
    zipCode!: string;
    password!: string;
    newPassword?: string | undefined;
    confirmNewPassword?: string | undefined;
    message?: string | undefined;

    constructor(data?: IEditUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.phoneNumber = _data["phoneNumber"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.address = _data["address"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.zipCode = _data["zipCode"];
            this.password = _data["password"];
            this.newPassword = _data["newPassword"];
            this.confirmNewPassword = _data["confirmNewPassword"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): EditUserModel {
        data = typeof data === 'object' ? data : {};
        let result = new EditUserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["phoneNumber"] = this.phoneNumber;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["address"] = this.address;
        data["country"] = this.country;
        data["state"] = this.state;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        data["password"] = this.password;
        data["newPassword"] = this.newPassword;
        data["confirmNewPassword"] = this.confirmNewPassword;
        data["message"] = this.message;
        return data;
    }
}

export interface IEditUserModel {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userName?: string | undefined;
    email?: string | undefined;
    phoneNumber?: string | undefined;
    birthDate?: Date;
    gender: string;
    address: string;
    country: string;
    state: string;
    city: string;
    zipCode: string;
    password: string;
    newPassword?: string | undefined;
    confirmNewPassword?: string | undefined;
    message?: string | undefined;
}

export class Image implements IImage {
    id?: string | undefined;
    imgUrl?: string | undefined;
    productImgId?: string | undefined;
    imgByte?: string | undefined;

    constructor(data?: IImage) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.imgUrl = _data["imgUrl"];
            this.productImgId = _data["productImgId"];
            this.imgByte = _data["imgByte"];
        }
    }

    static fromJS(data: any): Image {
        data = typeof data === 'object' ? data : {};
        let result = new Image();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["imgUrl"] = this.imgUrl;
        data["productImgId"] = this.productImgId;
        data["imgByte"] = this.imgByte;
        return data;
    }
}

export interface IImage {
    id?: string | undefined;
    imgUrl?: string | undefined;
    productImgId?: string | undefined;
    imgByte?: string | undefined;
}

export class Order implements IOrder {
    id?: string | undefined;
    fullName?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    orderTotal?: number;
    orderPlaced?: Date;
    isOrderCompleted?: boolean;
    userId?: string | undefined;
    user?: ApplicationUser;
    orderProducts?: OrderProduct[] | undefined;

    constructor(data?: IOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.orderTotal = _data["orderTotal"];
            this.orderPlaced = _data["orderPlaced"] ? new Date(_data["orderPlaced"].toString()) : <any>undefined;
            this.isOrderCompleted = _data["isOrderCompleted"];
            this.userId = _data["userId"];
            this.user = _data["user"] ? ApplicationUser.fromJS(_data["user"]) : <any>undefined;
            if (Array.isArray(_data["orderProducts"])) {
                this.orderProducts = [] as any;
                for (let item of _data["orderProducts"])
                    this.orderProducts!.push(OrderProduct.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Order {
        data = typeof data === 'object' ? data : {};
        let result = new Order();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["orderTotal"] = this.orderTotal;
        data["orderPlaced"] = this.orderPlaced ? this.orderPlaced.toISOString() : <any>undefined;
        data["isOrderCompleted"] = this.isOrderCompleted;
        data["userId"] = this.userId;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        if (Array.isArray(this.orderProducts)) {
            data["orderProducts"] = [];
            for (let item of this.orderProducts)
                data["orderProducts"].push(item.toJSON());
        }
        return data;
    }
}

export interface IOrder {
    id?: string | undefined;
    fullName?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    orderTotal?: number;
    orderPlaced?: Date;
    isOrderCompleted?: boolean;
    userId?: string | undefined;
    user?: ApplicationUser;
    orderProducts?: OrderProduct[] | undefined;
}

export class OrderProduct implements IOrderProduct {
    id?: string | undefined;
    price?: number;
    qty?: number;
    totalAmount?: number;
    orderId?: string | undefined;
    order?: Order;
    productId?: string | undefined;
    product?: Product;

    constructor(data?: IOrderProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.qty = _data["qty"];
            this.totalAmount = _data["totalAmount"];
            this.orderId = _data["orderId"];
            this.order = _data["order"] ? Order.fromJS(_data["order"]) : <any>undefined;
            this.productId = _data["productId"];
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
        }
    }

    static fromJS(data: any): OrderProduct {
        data = typeof data === 'object' ? data : {};
        let result = new OrderProduct();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["qty"] = this.qty;
        data["totalAmount"] = this.totalAmount;
        data["orderId"] = this.orderId;
        data["order"] = this.order ? this.order.toJSON() : <any>undefined;
        data["productId"] = this.productId;
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        return data;
    }
}

export interface IOrderProduct {
    id?: string | undefined;
    price?: number;
    qty?: number;
    totalAmount?: number;
    orderId?: string | undefined;
    order?: Order;
    productId?: string | undefined;
    product?: Product;
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
}

export class Product implements IProduct {
    id?: string | undefined;
    name!: string;
    shortDescription!: string;
    longDescription!: string;
    price!: number;
    stock!: number;
    color?: string | undefined;
    isTopProduct?: boolean;
    ref?: string | undefined;
    categoryId?: string | undefined;
    imgUrl?: string | undefined;
    orderProducts?: OrderProduct[] | undefined;
    cartItems?: CartItem[] | undefined;
    productImgs?: Image[] | undefined;

    constructor(data?: IProduct) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.shortDescription = _data["shortDescription"];
            this.longDescription = _data["longDescription"];
            this.price = _data["price"];
            this.stock = _data["stock"];
            this.color = _data["color"];
            this.isTopProduct = _data["isTopProduct"];
            this.ref = _data["ref"];
            this.categoryId = _data["categoryId"];
            this.imgUrl = _data["imgUrl"];
            if (Array.isArray(_data["orderProducts"])) {
                this.orderProducts = [] as any;
                for (let item of _data["orderProducts"])
                    this.orderProducts!.push(OrderProduct.fromJS(item));
            }
            if (Array.isArray(_data["cartItems"])) {
                this.cartItems = [] as any;
                for (let item of _data["cartItems"])
                    this.cartItems!.push(CartItem.fromJS(item));
            }
            if (Array.isArray(_data["productImgs"])) {
                this.productImgs = [] as any;
                for (let item of _data["productImgs"])
                    this.productImgs!.push(Image.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Product {
        data = typeof data === 'object' ? data : {};
        let result = new Product();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["shortDescription"] = this.shortDescription;
        data["longDescription"] = this.longDescription;
        data["price"] = this.price;
        data["stock"] = this.stock;
        data["color"] = this.color;
        data["isTopProduct"] = this.isTopProduct;
        data["ref"] = this.ref;
        data["categoryId"] = this.categoryId;
        data["imgUrl"] = this.imgUrl;
        if (Array.isArray(this.orderProducts)) {
            data["orderProducts"] = [];
            for (let item of this.orderProducts)
                data["orderProducts"].push(item.toJSON());
        }
        if (Array.isArray(this.cartItems)) {
            data["cartItems"] = [];
            for (let item of this.cartItems)
                data["cartItems"].push(item.toJSON());
        }
        if (Array.isArray(this.productImgs)) {
            data["productImgs"] = [];
            for (let item of this.productImgs)
                data["productImgs"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProduct {
    id?: string | undefined;
    name: string;
    shortDescription: string;
    longDescription: string;
    price: number;
    stock: number;
    color?: string | undefined;
    isTopProduct?: boolean;
    ref?: string | undefined;
    categoryId?: string | undefined;
    imgUrl?: string | undefined;
    orderProducts?: OrderProduct[] | undefined;
    cartItems?: CartItem[] | undefined;
    productImgs?: Image[] | undefined;
}

export class ProductListResponce implements IProductListResponce {
    data?: Product[] | undefined;

    constructor(data?: IProductListResponce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Product.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ProductListResponce {
        data = typeof data === 'object' ? data : {};
        let result = new ProductListResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        return data;
    }
}

export interface IProductListResponce {
    data?: Product[] | undefined;
}

export class ProductPagedResponce implements IProductPagedResponce {
    data?: Product[] | undefined;
    pageNumber?: number | undefined;
    pageSize?: number | undefined;
    nextPage?: string | undefined;
    previousPage?: string | undefined;

    constructor(data?: IProductPagedResponce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data!.push(Product.fromJS(item));
            }
            this.pageNumber = _data["pageNumber"];
            this.pageSize = _data["pageSize"];
            this.nextPage = _data["nextPage"];
            this.previousPage = _data["previousPage"];
        }
    }

    static fromJS(data: any): ProductPagedResponce {
        data = typeof data === 'object' ? data : {};
        let result = new ProductPagedResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["pageNumber"] = this.pageNumber;
        data["pageSize"] = this.pageSize;
        data["nextPage"] = this.nextPage;
        data["previousPage"] = this.previousPage;
        return data;
    }
}

export interface IProductPagedResponce {
    data?: Product[] | undefined;
    pageNumber?: number | undefined;
    pageSize?: number | undefined;
    nextPage?: string | undefined;
    previousPage?: string | undefined;
}

export class RegisterModel implements IRegisterModel {
    firstName!: string;
    lastName!: string;
    username!: string;
    email!: string;
    password!: string;
    birthDate?: Date;
    gender?: string | undefined;
    address?: string | undefined;
    country?: string | undefined;
    state?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;

    constructor(data?: IRegisterModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.username = _data["username"];
            this.email = _data["email"];
            this.password = _data["password"];
            this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
            this.gender = _data["gender"];
            this.address = _data["address"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.zipCode = _data["zipCode"];
        }
    }

    static fromJS(data: any): RegisterModel {
        data = typeof data === 'object' ? data : {};
        let result = new RegisterModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["username"] = this.username;
        data["email"] = this.email;
        data["password"] = this.password;
        data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
        data["gender"] = this.gender;
        data["address"] = this.address;
        data["country"] = this.country;
        data["state"] = this.state;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        return data;
    }
}

export interface IRegisterModel {
    firstName: string;
    lastName: string;
    username: string;
    email: string;
    password: string;
    birthDate?: Date;
    gender?: string | undefined;
    address?: string | undefined;
    country?: string | undefined;
    state?: string | undefined;
    city?: string | undefined;
    zipCode?: string | undefined;
}

export class RequestOrder implements IRequestOrder {
    fullName?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    orderTotal?: number;
    orderPlaced?: Date;
    isOrderCompleted?: boolean;
    userId?: string | undefined;

    constructor(data?: IRequestOrder) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.fullName = _data["fullName"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.orderTotal = _data["orderTotal"];
            this.orderPlaced = _data["orderPlaced"] ? new Date(_data["orderPlaced"].toString()) : <any>undefined;
            this.isOrderCompleted = _data["isOrderCompleted"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): RequestOrder {
        data = typeof data === 'object' ? data : {};
        let result = new RequestOrder();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fullName"] = this.fullName;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["orderTotal"] = this.orderTotal;
        data["orderPlaced"] = this.orderPlaced ? this.orderPlaced.toISOString() : <any>undefined;
        data["isOrderCompleted"] = this.isOrderCompleted;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IRequestOrder {
    fullName?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    orderTotal?: number;
    orderPlaced?: Date;
    isOrderCompleted?: boolean;
    userId?: string | undefined;
}

export class ResponceCartItem implements IResponceCartItem {
    id?: string | undefined;
    price?: number;
    qty?: number;
    totalAmount?: number;
    productName?: string | undefined;
    productShortDescription?: string | undefined;
    image?: Image;

    constructor(data?: IResponceCartItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.price = _data["price"];
            this.qty = _data["qty"];
            this.totalAmount = _data["totalAmount"];
            this.productName = _data["productName"];
            this.productShortDescription = _data["productShortDescription"];
            this.image = _data["image"] ? Image.fromJS(_data["image"]) : <any>undefined;
        }
    }

    static fromJS(data: any): ResponceCartItem {
        data = typeof data === 'object' ? data : {};
        let result = new ResponceCartItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["price"] = this.price;
        data["qty"] = this.qty;
        data["totalAmount"] = this.totalAmount;
        data["productName"] = this.productName;
        data["productShortDescription"] = this.productShortDescription;
        data["image"] = this.image ? this.image.toJSON() : <any>undefined;
        return data;
    }
}

export interface IResponceCartItem {
    id?: string | undefined;
    price?: number;
    qty?: number;
    totalAmount?: number;
    productName?: string | undefined;
    productShortDescription?: string | undefined;
    image?: Image;
}

export class ResponceOrderDetailDto implements IResponceOrderDetailDto {
    price?: number;
    qty?: number;
    totalAmount?: number;
    orderId?: string | undefined;
    productId?: string | undefined;
    productName?: string | undefined;

    constructor(data?: IResponceOrderDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.price = _data["price"];
            this.qty = _data["qty"];
            this.totalAmount = _data["totalAmount"];
            this.orderId = _data["orderId"];
            this.productId = _data["productId"];
            this.productName = _data["productName"];
        }
    }

    static fromJS(data: any): ResponceOrderDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponceOrderDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["price"] = this.price;
        data["qty"] = this.qty;
        data["totalAmount"] = this.totalAmount;
        data["orderId"] = this.orderId;
        data["productId"] = this.productId;
        data["productName"] = this.productName;
        return data;
    }
}

export interface IResponceOrderDetailDto {
    price?: number;
    qty?: number;
    totalAmount?: number;
    orderId?: string | undefined;
    productId?: string | undefined;
    productName?: string | undefined;
}

export class ResponceOrderDto implements IResponceOrderDto {
    id?: string | undefined;
    fullName?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    orderTotal?: number;
    orderPlaced?: Date;
    isOrderCompleted?: boolean;
    userId?: string | undefined;

    constructor(data?: IResponceOrderDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fullName = _data["fullName"];
            this.address = _data["address"];
            this.phone = _data["phone"];
            this.orderTotal = _data["orderTotal"];
            this.orderPlaced = _data["orderPlaced"] ? new Date(_data["orderPlaced"].toString()) : <any>undefined;
            this.isOrderCompleted = _data["isOrderCompleted"];
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): ResponceOrderDto {
        data = typeof data === 'object' ? data : {};
        let result = new ResponceOrderDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fullName"] = this.fullName;
        data["address"] = this.address;
        data["phone"] = this.phone;
        data["orderTotal"] = this.orderTotal;
        data["orderPlaced"] = this.orderPlaced ? this.orderPlaced.toISOString() : <any>undefined;
        data["isOrderCompleted"] = this.isOrderCompleted;
        data["userId"] = this.userId;
        return data;
    }
}

export interface IResponceOrderDto {
    id?: string | undefined;
    fullName?: string | undefined;
    address?: string | undefined;
    phone?: string | undefined;
    orderTotal?: number;
    orderPlaced?: Date;
    isOrderCompleted?: boolean;
    userId?: string | undefined;
}

export class ResponceProductDTO implements IResponceProductDTO {
    product?: Product;
    images?: Image[] | undefined;

    constructor(data?: IResponceProductDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.product = _data["product"] ? Product.fromJS(_data["product"]) : <any>undefined;
            if (Array.isArray(_data["images"])) {
                this.images = [] as any;
                for (let item of _data["images"])
                    this.images!.push(Image.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ResponceProductDTO {
        data = typeof data === 'object' ? data : {};
        let result = new ResponceProductDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["product"] = this.product ? this.product.toJSON() : <any>undefined;
        if (Array.isArray(this.images)) {
            data["images"] = [];
            for (let item of this.images)
                data["images"].push(item.toJSON());
        }
        return data;
    }
}

export interface IResponceProductDTO {
    product?: Product;
    images?: Image[] | undefined;
}

export class SubTotalAmountResponce implements ISubTotalAmountResponce {
    totalAmount?: number;

    constructor(data?: ISubTotalAmountResponce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalAmount = _data["totalAmount"];
        }
    }

    static fromJS(data: any): SubTotalAmountResponce {
        data = typeof data === 'object' ? data : {};
        let result = new SubTotalAmountResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalAmount"] = this.totalAmount;
        return data;
    }
}

export interface ISubTotalAmountResponce {
    totalAmount?: number;
}

export class TokenRequestModel implements ITokenRequestModel {
    email!: string;
    password!: string;

    constructor(data?: ITokenRequestModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): TokenRequestModel {
        data = typeof data === 'object' ? data : {};
        let result = new TokenRequestModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["password"] = this.password;
        return data;
    }
}

export interface ITokenRequestModel {
    email: string;
    password: string;
}

export class TotalItemsQtyResponce implements ITotalItemsQtyResponce {
    totalItems?: number;

    constructor(data?: ITotalItemsQtyResponce) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.totalItems = _data["totalItems"];
        }
    }

    static fromJS(data: any): TotalItemsQtyResponce {
        data = typeof data === 'object' ? data : {};
        let result = new TotalItemsQtyResponce();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["totalItems"] = this.totalItems;
        return data;
    }
}

export interface ITotalItemsQtyResponce {
    totalItems?: number;
}

export class UserModel implements IUserModel {
    id?: string | undefined;
    firstName!: string;
    lastName!: string;
    userName!: string;
    email!: string;
    gender!: string;
    address!: string;
    country!: string;
    state!: string;
    city!: string;
    zipCode!: string;
    message?: string | undefined;
    password!: string;

    constructor(data?: IUserModel) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userName = _data["userName"];
            this.email = _data["email"];
            this.gender = _data["gender"];
            this.address = _data["address"];
            this.country = _data["country"];
            this.state = _data["state"];
            this.city = _data["city"];
            this.zipCode = _data["zipCode"];
            this.message = _data["message"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): UserModel {
        data = typeof data === 'object' ? data : {};
        let result = new UserModel();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userName"] = this.userName;
        data["email"] = this.email;
        data["gender"] = this.gender;
        data["address"] = this.address;
        data["country"] = this.country;
        data["state"] = this.state;
        data["city"] = this.city;
        data["zipCode"] = this.zipCode;
        data["message"] = this.message;
        data["password"] = this.password;
        return data;
    }
}

export interface IUserModel {
    id?: string | undefined;
    firstName: string;
    lastName: string;
    userName: string;
    email: string;
    gender: string;
    address: string;
    country: string;
    state: string;
    city: string;
    zipCode: string;
    message?: string | undefined;
    password: string;
}

export class WeatherForecast implements IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    readonly temperatureF?: number;
    summary?: string | undefined;

    constructor(data?: IWeatherForecast) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.temperatureC = _data["temperatureC"];
            (<any>this).temperatureF = _data["temperatureF"];
            this.summary = _data["summary"];
        }
    }

    static fromJS(data: any): WeatherForecast {
        data = typeof data === 'object' ? data : {};
        let result = new WeatherForecast();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["temperatureC"] = this.temperatureC;
        data["temperatureF"] = this.temperatureF;
        data["summary"] = this.summary;
        return data;
    }
}

export interface IWeatherForecast {
    date?: Date;
    temperatureC?: number;
    temperatureF?: number;
    summary?: string | undefined;
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
